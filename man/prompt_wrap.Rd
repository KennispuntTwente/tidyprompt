% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prompt_wrap.R
\name{prompt_wrap}
\alias{prompt_wrap}
\title{Wrap a prompt with empowering functions}
\usage{
prompt_wrap(
  prompt,
  modify_fn = NULL,
  extraction_fn = NULL,
  validation_fn = NULL,
  type = c("unspecified", "mode", "tool")
)
}
\arguments{
\item{prompt}{A single string or a \code{\link[=tidyprompt]{tidyprompt()}} object}

\item{modify_fn}{A function that takes the previous prompt text (as
first argument) and returns the new prompt text}

\item{extraction_fn}{A function that takes the LLM response (as first argument)
and attempts to extract a value from it.Upon succesful extraction, the function
should return the extracted value. If the extraction fails, the function should
return a \code{\link[=llm_feedback]{llm_feedback()}} message which will be sent back to the LLM}

\item{validation_fn}{A function that takes the (extracted) LLM response
(as first argument) and attempts to validate it. Upon succesful validation,
the function should return TRUE. If the validation fails, the function should
return a \code{\link[=llm_feedback]{llm_feedback()}} message which will be sent back to the LLM}

\item{type}{The type of prompt wrap; one of 'unspecified', 'mode', 'tool', or 'break'.
Types are used to determine the order in which prompt wraps are applied.
When constructing the prompt text, prompt wraps are applied to the base prompt
in the following order: 'unspecified', 'break', 'mode', 'tool'. When evaluating
the LLM response and applying extraction and validation functions,
prompt wraps are applied in the reverse order: 'tool', 'mode', 'break', 'unspecified'.
Example of a tool is \code{\link[=add_tools]{add_tools()}}; example of a mode is \code{\link[=answer_by_react]{answer_by_react()}}.
Example of a break is \code{\link[=quit_if]{quit_if()}}. Most other prompt wraps will be 'unspecified',
like \code{\link[=answer_as_regex]{answer_as_regex()}} or \code{\link[=add_text]{add_text()}}}
}
\value{
A \code{\link[=tidyprompt]{tidyprompt()}} object with the \code{\link[=prompt_wrap]{prompt_wrap()}} appended to it
}
\description{
This function takes a single string or a \code{\link[=tidyprompt]{tidyprompt()}} object and
adds a new prompt wrap to it. A prompt wrap is a set of functions
that modify the prompt text, extract a value from the LLM response,
and validate the extracted value. The functions are used to ensure
that the prompt and LLM response is in the correct format and meets the
specified criteria.
}
\examples{
#' Make LLM answer as an integer (between min and max)
#'
#' @param prompt A single string or a [tidyprompt()] object
#' @param min (optional) Minimum value for the integer
#' @param max (optional) Maximum value for the integer
#' @param add_instruction_to_prompt (optional) Add instruction for replying
#' as an integer to the prompt text. Set to FALSE for debugging if extractions/validations
#' are working as expected (without instruction the answer should fail the
#' validation function, initiating a retry)
#'
#' @return A [tidyprompt()] with an added [prompt_wrap()] which
#' will ensure that the LLM response is an integer.
#'
#' @export
#'
#' @example inst/examples/answer_as_integer.R
#'
#' @family pre_built_prompt_wraps
#' @family answer_as_prompt_wraps
answer_as_integer <- function(
    prompt,
    min = NULL,
    max = NULL,
    add_instruction_to_prompt = TRUE
) {
  instruction <- "You must answer with only an integer (use no other characters)."

  if (!is.null(min) && !is.null(max)) {
    instruction <- paste(instruction, glue::glue(
      "Enter an integer between {min} and {max}."
    ))
  } else if (!is.null(min)) {
    instruction <- paste(instruction, glue::glue(
      "Enter an integer greater than or equal to {min}."
    ))
  } else if (!is.null(max)) {
    instruction <- paste(instruction, glue::glue(
      "Enter an integer less than or equal to {max}."
    ))
  }


  # Define modification/extraction/validation functions:
  modify_fn <- function(original_prompt_text) {
    if (!add_instruction_to_prompt) {
      return(original_prompt_text)
    }

    glue::glue("{original_prompt_text}\n\n{instruction}")
  }

  extraction_fn <- function(x) {
    extracted <- suppressWarnings(as.numeric(x))
    if (is.na(extracted)) {
      return(llm_feedback(instruction))
    }
    return(extracted)
  }

  validation_fn <- function(x) {
    if (x != floor(x)) { # Not a whole number
      return(llm_feedback(instruction))
    }

    if (!is.null(min) && x < min) {
      return(llm_feedback(glue::glue(
        "The number should be greater than or equal to {min}."
      )))
    }
    if (!is.null(max) && x > max) {
      return(llm_feedback(glue::glue(
        "The number should be less than or equal to {max}."
      )))
    }
    return(TRUE)
  }

  prompt_wrap(prompt, modify_fn, extraction_fn, validation_fn)
}
}
\seealso{
\code{\link[=tidyprompt]{tidyprompt()}} \code{\link[=send_prompt]{send_prompt()}}

Other prompt_wrap: 
\code{\link{llm_break}()},
\code{\link{llm_feedback}()}

Other pre_built_prompt_wraps: 
\code{\link{add_text}()},
\code{\link{add_tools}()},
\code{\link{answer_as_boolean}()},
\code{\link{answer_as_code}()},
\code{\link{answer_as_integer}()},
\code{\link{answer_as_list}()},
\code{\link{answer_as_named_list}()},
\code{\link{answer_as_regex}()},
\code{\link{answer_by_chain_of_thought}()},
\code{\link{answer_by_react}()},
\code{\link{quit_if}()},
\code{\link{set_system_prompt}()}
}
\concept{pre_built_prompt_wraps}
\concept{prompt_wrap}
